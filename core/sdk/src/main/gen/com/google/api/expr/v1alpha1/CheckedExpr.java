// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/expr/v1alpha1/checked.proto

// Protobuf Java Version: 3.25.2
package com.google.api.expr.v1alpha1;

/**
 * <pre>
 * A CEL expression which has been successfully type checked.
 * </pre>
 *
 * Protobuf type {@code google.api.expr.v1alpha1.CheckedExpr}
 */
public  final class CheckedExpr extends
    com.google.protobuf.GeneratedMessageLite<
        CheckedExpr, CheckedExpr.Builder> implements
    // @@protoc_insertion_point(message_implements:google.api.expr.v1alpha1.CheckedExpr)
    CheckedExprOrBuilder {
  private CheckedExpr() {
    exprVersion_ = "";
  }
  private int bitField0_;
  public static final int REFERENCE_MAP_FIELD_NUMBER = 2;
  private static final class ReferenceMapDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.Long, com.google.api.expr.v1alpha1.Reference> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.Long, com.google.api.expr.v1alpha1.Reference>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.INT64,
                0L,
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.api.expr.v1alpha1.Reference.getDefaultInstance());
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.Long, com.google.api.expr.v1alpha1.Reference> referenceMap_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Reference>
  internalGetReferenceMap() {
    return referenceMap_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Reference>
  internalGetMutableReferenceMap() {
    if (!referenceMap_.isMutable()) {
      referenceMap_ = referenceMap_.mutableCopy();
    }
    return referenceMap_;
  }
  @java.lang.Override

  public int getReferenceMapCount() {
    return internalGetReferenceMap().size();
  }
  /**
   * <pre>
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
   */
  @java.lang.Override

  public boolean containsReferenceMap(
      long key) {

    return internalGetReferenceMap().containsKey(key);
  }
  /**
   * Use {@link #getReferenceMapMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> getReferenceMap() {
    return getReferenceMapMap();
  }
  /**
   * <pre>
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> getReferenceMapMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetReferenceMap());
  }
  /**
   * <pre>
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
   */
  @java.lang.Override

  public /* nullable */
com.google.api.expr.v1alpha1.Reference getReferenceMapOrDefault(
      long key,
      /* nullable */
com.google.api.expr.v1alpha1.Reference defaultValue) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> map =
        internalGetReferenceMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
   */
  @java.lang.Override

  public com.google.api.expr.v1alpha1.Reference getReferenceMapOrThrow(
      long key) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> map =
        internalGetReferenceMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
   */
  private java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference>
  getMutableReferenceMapMap() {
    return internalGetMutableReferenceMap();
  }

  public static final int TYPE_MAP_FIELD_NUMBER = 3;
  private static final class TypeMapDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.Long, com.google.api.expr.v1alpha1.Type> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.Long, com.google.api.expr.v1alpha1.Type>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.INT64,
                0L,
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.api.expr.v1alpha1.Type.getDefaultInstance());
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.Long, com.google.api.expr.v1alpha1.Type> typeMap_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Type>
  internalGetTypeMap() {
    return typeMap_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Type>
  internalGetMutableTypeMap() {
    if (!typeMap_.isMutable()) {
      typeMap_ = typeMap_.mutableCopy();
    }
    return typeMap_;
  }
  @java.lang.Override

  public int getTypeMapCount() {
    return internalGetTypeMap().size();
  }
  /**
   * <pre>
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
   */
  @java.lang.Override

  public boolean containsTypeMap(
      long key) {

    return internalGetTypeMap().containsKey(key);
  }
  /**
   * Use {@link #getTypeMapMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> getTypeMap() {
    return getTypeMapMap();
  }
  /**
   * <pre>
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> getTypeMapMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetTypeMap());
  }
  /**
   * <pre>
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
   */
  @java.lang.Override

  public /* nullable */
com.google.api.expr.v1alpha1.Type getTypeMapOrDefault(
      long key,
      /* nullable */
com.google.api.expr.v1alpha1.Type defaultValue) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> map =
        internalGetTypeMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
   */
  @java.lang.Override

  public com.google.api.expr.v1alpha1.Type getTypeMapOrThrow(
      long key) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> map =
        internalGetTypeMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
   */
  private java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type>
  getMutableTypeMapMap() {
    return internalGetMutableTypeMap();
  }

  public static final int SOURCE_INFO_FIELD_NUMBER = 5;
  private com.google.api.expr.v1alpha1.SourceInfo sourceInfo_;
  /**
   * <pre>
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
   */
  @java.lang.Override
  public boolean hasSourceInfo() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
   */
  @java.lang.Override
  public com.google.api.expr.v1alpha1.SourceInfo getSourceInfo() {
    return sourceInfo_ == null ? com.google.api.expr.v1alpha1.SourceInfo.getDefaultInstance() : sourceInfo_;
  }
  /**
   * <pre>
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
   */
  private void setSourceInfo(com.google.api.expr.v1alpha1.SourceInfo value) {
    value.getClass();
  sourceInfo_ = value;
    bitField0_ |= 0x00000001;
    }
  /**
   * <pre>
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeSourceInfo(com.google.api.expr.v1alpha1.SourceInfo value) {
    value.getClass();
  if (sourceInfo_ != null &&
        sourceInfo_ != com.google.api.expr.v1alpha1.SourceInfo.getDefaultInstance()) {
      sourceInfo_ =
        com.google.api.expr.v1alpha1.SourceInfo.newBuilder(sourceInfo_).mergeFrom(value).buildPartial();
    } else {
      sourceInfo_ = value;
    }
    bitField0_ |= 0x00000001;
  }
  /**
   * <pre>
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
   */
  private void clearSourceInfo() {  sourceInfo_ = null;
    bitField0_ = (bitField0_ & ~0x00000001);
  }

  public static final int EXPR_VERSION_FIELD_NUMBER = 6;
  private java.lang.String exprVersion_;
  /**
   * <pre>
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   * </pre>
   *
   * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
   * @return The exprVersion.
   */
  @java.lang.Override
  public java.lang.String getExprVersion() {
    return exprVersion_;
  }
  /**
   * <pre>
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   * </pre>
   *
   * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
   * @return The bytes for exprVersion.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getExprVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(exprVersion_);
  }
  /**
   * <pre>
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   * </pre>
   *
   * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
   * @param value The exprVersion to set.
   */
  private void setExprVersion(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    exprVersion_ = value;
  }
  /**
   * <pre>
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   * </pre>
   *
   * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
   */
  private void clearExprVersion() {

    exprVersion_ = getDefaultInstance().getExprVersion();
  }
  /**
   * <pre>
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   * </pre>
   *
   * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
   * @param value The bytes for exprVersion to set.
   */
  private void setExprVersionBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    exprVersion_ = value.toStringUtf8();

  }

  public static final int EXPR_FIELD_NUMBER = 4;
  private com.google.api.expr.v1alpha1.Expr expr_;
  /**
   * <pre>
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
   */
  @java.lang.Override
  public boolean hasExpr() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
   */
  @java.lang.Override
  public com.google.api.expr.v1alpha1.Expr getExpr() {
    return expr_ == null ? com.google.api.expr.v1alpha1.Expr.getDefaultInstance() : expr_;
  }
  /**
   * <pre>
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
   */
  private void setExpr(com.google.api.expr.v1alpha1.Expr value) {
    value.getClass();
  expr_ = value;
    bitField0_ |= 0x00000002;
    }
  /**
   * <pre>
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeExpr(com.google.api.expr.v1alpha1.Expr value) {
    value.getClass();
  if (expr_ != null &&
        expr_ != com.google.api.expr.v1alpha1.Expr.getDefaultInstance()) {
      expr_ =
        com.google.api.expr.v1alpha1.Expr.newBuilder(expr_).mergeFrom(value).buildPartial();
    } else {
      expr_ = value;
    }
    bitField0_ |= 0x00000002;
  }
  /**
   * <pre>
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   * </pre>
   *
   * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
   */
  private void clearExpr() {  expr_ = null;
    bitField0_ = (bitField0_ & ~0x00000002);
  }

  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static com.google.api.expr.v1alpha1.CheckedExpr parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.api.expr.v1alpha1.CheckedExpr parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.expr.v1alpha1.CheckedExpr parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(com.google.api.expr.v1alpha1.CheckedExpr prototype) {
    return DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A CEL expression which has been successfully type checked.
   * </pre>
   *
   * Protobuf type {@code google.api.expr.v1alpha1.CheckedExpr}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.api.expr.v1alpha1.CheckedExpr, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.api.expr.v1alpha1.CheckedExpr)
      com.google.api.expr.v1alpha1.CheckedExprOrBuilder {
    // Construct using com.google.api.expr.v1alpha1.CheckedExpr.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    @java.lang.Override

    public int getReferenceMapCount() {
      return instance.getReferenceMapMap().size();
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    @java.lang.Override

    public boolean containsReferenceMap(
        long key) {

      return instance.getReferenceMapMap().containsKey(key);
    }

    public Builder clearReferenceMap() {
      copyOnWrite();
      instance.getMutableReferenceMapMap().clear();
      return this;
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */

    public Builder removeReferenceMap(
        long key) {

      copyOnWrite();
      instance.getMutableReferenceMapMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getReferenceMapMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> getReferenceMap() {
      return getReferenceMapMap();
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> getReferenceMapMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getReferenceMapMap());
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    @java.lang.Override

    public /* nullable */
com.google.api.expr.v1alpha1.Reference getReferenceMapOrDefault(
        long key,
        /* nullable */
com.google.api.expr.v1alpha1.Reference defaultValue) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> map =
          instance.getReferenceMapMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    @java.lang.Override

    public com.google.api.expr.v1alpha1.Reference getReferenceMapOrThrow(
        long key) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> map =
          instance.getReferenceMapMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    public Builder putReferenceMap(
        long key,
        com.google.api.expr.v1alpha1.Reference value) {

      java.lang.Class<?> valueClass = value.getClass();
      copyOnWrite();
      instance.getMutableReferenceMapMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * A map from expression ids to resolved references.
     *
     * The following entries are in this table:
     *
     * - An Ident or Select expression is represented here if it resolves to a
     *   declaration. For instance, if `a.b.c` is represented by
     *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
     *   while `c` is a field selection, then the reference is attached to the
     *   nested select expression (but not to the id or or the outer select).
     *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
     *   the reference is attached to the ident expression.
     * - Every Call expression has an entry here, identifying the function being
     *   called.
     * - Every CreateStruct expression for a message has an entry, identifying
     *   the message.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Reference&gt; reference_map = 2 [json_name = "referenceMap"];</code>
     */
    public Builder putAllReferenceMap(
        java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Reference> values) {
      copyOnWrite();
      instance.getMutableReferenceMapMap().putAll(values);
      return this;
    }

    @java.lang.Override

    public int getTypeMapCount() {
      return instance.getTypeMapMap().size();
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    @java.lang.Override

    public boolean containsTypeMap(
        long key) {

      return instance.getTypeMapMap().containsKey(key);
    }

    public Builder clearTypeMap() {
      copyOnWrite();
      instance.getMutableTypeMapMap().clear();
      return this;
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */

    public Builder removeTypeMap(
        long key) {

      copyOnWrite();
      instance.getMutableTypeMapMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getTypeMapMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> getTypeMap() {
      return getTypeMapMap();
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> getTypeMapMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getTypeMapMap());
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    @java.lang.Override

    public /* nullable */
com.google.api.expr.v1alpha1.Type getTypeMapOrDefault(
        long key,
        /* nullable */
com.google.api.expr.v1alpha1.Type defaultValue) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> map =
          instance.getTypeMapMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    @java.lang.Override

    public com.google.api.expr.v1alpha1.Type getTypeMapOrThrow(
        long key) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> map =
          instance.getTypeMapMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    public Builder putTypeMap(
        long key,
        com.google.api.expr.v1alpha1.Type value) {

      java.lang.Class<?> valueClass = value.getClass();
      copyOnWrite();
      instance.getMutableTypeMapMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * A map from expression ids to types.
     *
     * Every expression node which has a type different than DYN has a mapping
     * here. If an expression has type DYN, it is omitted from this map to save
     * space.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Type&gt; type_map = 3 [json_name = "typeMap"];</code>
     */
    public Builder putAllTypeMap(
        java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Type> values) {
      copyOnWrite();
      instance.getMutableTypeMapMap().putAll(values);
      return this;
    }

    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    @java.lang.Override
    public boolean hasSourceInfo() {
      return instance.hasSourceInfo();
    }
    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    @java.lang.Override
    public com.google.api.expr.v1alpha1.SourceInfo getSourceInfo() {
      return instance.getSourceInfo();
    }
    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    public Builder setSourceInfo(com.google.api.expr.v1alpha1.SourceInfo value) {
      copyOnWrite();
      instance.setSourceInfo(value);
      return this;
      }
    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    public Builder setSourceInfo(
        com.google.api.expr.v1alpha1.SourceInfo.Builder builderForValue) {
      copyOnWrite();
      instance.setSourceInfo(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    public Builder mergeSourceInfo(com.google.api.expr.v1alpha1.SourceInfo value) {
      copyOnWrite();
      instance.mergeSourceInfo(value);
      return this;
    }
    /**
     * <pre>
     * The source info derived from input that generated the parsed `expr` and
     * any optimizations made during the type-checking pass.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo source_info = 5 [json_name = "sourceInfo"];</code>
     */
    public Builder clearSourceInfo() {  copyOnWrite();
      instance.clearSourceInfo();
      return this;
    }

    /**
     * <pre>
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * </pre>
     *
     * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
     * @return The exprVersion.
     */
    @java.lang.Override
    public java.lang.String getExprVersion() {
      return instance.getExprVersion();
    }
    /**
     * <pre>
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * </pre>
     *
     * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
     * @return The bytes for exprVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExprVersionBytes() {
      return instance.getExprVersionBytes();
    }
    /**
     * <pre>
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * </pre>
     *
     * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
     * @param value The exprVersion to set.
     * @return This builder for chaining.
     */
    public Builder setExprVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setExprVersion(value);
      return this;
    }
    /**
     * <pre>
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * </pre>
     *
     * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
     * @return This builder for chaining.
     */
    public Builder clearExprVersion() {
      copyOnWrite();
      instance.clearExprVersion();
      return this;
    }
    /**
     * <pre>
     * The expr version indicates the major / minor version number of the `expr`
     * representation.
     *
     * The most common reason for a version change will be to indicate to the CEL
     * runtimes that transformations have been performed on the expr during static
     * analysis. In some cases, this will save the runtime the work of applying
     * the same or similar transformations prior to evaluation.
     * </pre>
     *
     * <code>string expr_version = 6 [json_name = "exprVersion"];</code>
     * @param value The bytes for exprVersion to set.
     * @return This builder for chaining.
     */
    public Builder setExprVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setExprVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    @java.lang.Override
    public boolean hasExpr() {
      return instance.hasExpr();
    }
    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    @java.lang.Override
    public com.google.api.expr.v1alpha1.Expr getExpr() {
      return instance.getExpr();
    }
    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    public Builder setExpr(com.google.api.expr.v1alpha1.Expr value) {
      copyOnWrite();
      instance.setExpr(value);
      return this;
      }
    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    public Builder setExpr(
        com.google.api.expr.v1alpha1.Expr.Builder builderForValue) {
      copyOnWrite();
      instance.setExpr(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    public Builder mergeExpr(com.google.api.expr.v1alpha1.Expr value) {
      copyOnWrite();
      instance.mergeExpr(value);
      return this;
    }
    /**
     * <pre>
     * The checked expression. Semantically equivalent to the parsed `expr`, but
     * may have structural differences.
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.Expr expr = 4 [json_name = "expr"];</code>
     */
    public Builder clearExpr() {  copyOnWrite();
      instance.clearExpr();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.api.expr.v1alpha1.CheckedExpr)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.api.expr.v1alpha1.CheckedExpr();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "referenceMap_",
            ReferenceMapDefaultEntryHolder.defaultEntry,
            "typeMap_",
            TypeMapDefaultEntryHolder.defaultEntry,
            "expr_",
            "sourceInfo_",
            "exprVersion_",
          };
          java.lang.String info =
              "\u0000\u0005\u0000\u0001\u0002\u0006\u0005\u0002\u0000\u0000\u00022\u00032\u0004" +
              "\u1009\u0001\u0005\u1009\u0000\u0006\u0208";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<com.google.api.expr.v1alpha1.CheckedExpr> parser = PARSER;
        if (parser == null) {
          synchronized (com.google.api.expr.v1alpha1.CheckedExpr.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<com.google.api.expr.v1alpha1.CheckedExpr>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.api.expr.v1alpha1.CheckedExpr)
  private static final com.google.api.expr.v1alpha1.CheckedExpr DEFAULT_INSTANCE;
  static {
    CheckedExpr defaultInstance = new CheckedExpr();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      CheckedExpr.class, defaultInstance);
  }

  public static com.google.api.expr.v1alpha1.CheckedExpr getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<CheckedExpr> PARSER;

  public static com.google.protobuf.Parser<CheckedExpr> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

