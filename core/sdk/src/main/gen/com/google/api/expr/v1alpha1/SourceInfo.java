// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: google/api/expr/v1alpha1/syntax.proto
// Protobuf Java Version: 4.28.3

package com.google.api.expr.v1alpha1;

/**
 * <pre>
 * Source information collected at parse time.
 * </pre>
 *
 * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo}
 */
public  final class SourceInfo extends
    com.google.protobuf.GeneratedMessageLite<
        SourceInfo, SourceInfo.Builder> implements
    // @@protoc_insertion_point(message_implements:google.api.expr.v1alpha1.SourceInfo)
    SourceInfoOrBuilder {
  private SourceInfo() {
    syntaxVersion_ = "";
    location_ = "";
    lineOffsets_ = emptyIntList();
    extensions_ = emptyProtobufList();
  }
  public interface ExtensionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.api.expr.v1alpha1.SourceInfo.Extension)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @return The id.
     */
    java.lang.String getId();
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @return The bytes for id.
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return A list containing the affectedComponents.
     */
    java.util.List<com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> getAffectedComponentsList();
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return The count of affectedComponents.
     */
    int getAffectedComponentsCount();
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param index The index of the element to return.
     * @return The affectedComponents at the given index.
     */
    com.google.api.expr.v1alpha1.SourceInfo.Extension.Component getAffectedComponents(int index);
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return A list containing the enum numeric values on the wire for affectedComponents.
     */
    java.util.List<java.lang.Integer>
    getAffectedComponentsValueList();
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of affectedComponents at the given index.
     */
    int getAffectedComponentsValue(int index);

    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     * @return The version.
     */
    com.google.api.expr.v1alpha1.SourceInfo.Extension.Version getVersion();
  }
  /**
   * <pre>
   * An extension that was requested for the source expression.
   * </pre>
   *
   * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo.Extension}
   */
  public  static final class Extension extends
      com.google.protobuf.GeneratedMessageLite<
          Extension, Extension.Builder> implements
      // @@protoc_insertion_point(message_implements:google.api.expr.v1alpha1.SourceInfo.Extension)
      ExtensionOrBuilder {
    private Extension() {
      id_ = "";
      affectedComponents_ = emptyIntList();
    }
    /**
     * <pre>
     * CEL component specifier.
     * </pre>
     *
     * Protobuf enum {@code google.api.expr.v1alpha1.SourceInfo.Extension.Component}
     */
    public enum Component
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Unspecified, default.
       * </pre>
       *
       * <code>COMPONENT_UNSPECIFIED = 0;</code>
       */
      COMPONENT_UNSPECIFIED(0),
      /**
       * <pre>
       * Parser. Converts a CEL string to an AST.
       * </pre>
       *
       * <code>COMPONENT_PARSER = 1;</code>
       */
      COMPONENT_PARSER(1),
      /**
       * <pre>
       * Type checker. Checks that references in an AST are defined and types
       * agree.
       * </pre>
       *
       * <code>COMPONENT_TYPE_CHECKER = 2;</code>
       */
      COMPONENT_TYPE_CHECKER(2),
      /**
       * <pre>
       * Runtime. Evaluates a parsed and optionally checked CEL AST against a
       * context.
       * </pre>
       *
       * <code>COMPONENT_RUNTIME = 3;</code>
       */
      COMPONENT_RUNTIME(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Unspecified, default.
       * </pre>
       *
       * <code>COMPONENT_UNSPECIFIED = 0;</code>
       */
      public static final int COMPONENT_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * Parser. Converts a CEL string to an AST.
       * </pre>
       *
       * <code>COMPONENT_PARSER = 1;</code>
       */
      public static final int COMPONENT_PARSER_VALUE = 1;
      /**
       * <pre>
       * Type checker. Checks that references in an AST are defined and types
       * agree.
       * </pre>
       *
       * <code>COMPONENT_TYPE_CHECKER = 2;</code>
       */
      public static final int COMPONENT_TYPE_CHECKER_VALUE = 2;
      /**
       * <pre>
       * Runtime. Evaluates a parsed and optionally checked CEL AST against a
       * context.
       * </pre>
       *
       * <code>COMPONENT_RUNTIME = 3;</code>
       */
      public static final int COMPONENT_RUNTIME_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Component valueOf(int value) {
        return forNumber(value);
      }

      public static Component forNumber(int value) {
        switch (value) {
          case 0: return COMPONENT_UNSPECIFIED;
          case 1: return COMPONENT_PARSER;
          case 2: return COMPONENT_TYPE_CHECKER;
          case 3: return COMPONENT_RUNTIME;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Component>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Component> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Component>() {
              @java.lang.Override
              public Component findValueByNumber(int number) {
                return Component.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ComponentVerifier.INSTANCE;
      }

      private static final class ComponentVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ComponentVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Component.forNumber(number) != null;
              }
            };

      private final int value;

      private Component(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.api.expr.v1alpha1.SourceInfo.Extension.Component)
    }

    public interface VersionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.api.expr.v1alpha1.SourceInfo.Extension.Version)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Major version changes indicate different required support level from
       * the required components.
       * </pre>
       *
       * <code>int64 major = 1 [json_name = "major"];</code>
       * @return The major.
       */
      long getMajor();

      /**
       * <pre>
       * Minor version changes must not change the observed behavior from
       * existing implementations, but may be provided informationally.
       * </pre>
       *
       * <code>int64 minor = 2 [json_name = "minor"];</code>
       * @return The minor.
       */
      long getMinor();
    }
    /**
     * <pre>
     * Version
     * </pre>
     *
     * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo.Extension.Version}
     */
    public  static final class Version extends
        com.google.protobuf.GeneratedMessageLite<
            Version, Version.Builder> implements
        // @@protoc_insertion_point(message_implements:google.api.expr.v1alpha1.SourceInfo.Extension.Version)
        VersionOrBuilder {
      private Version() {
      }
      public static final int MAJOR_FIELD_NUMBER = 1;
      private long major_;
      /**
       * <pre>
       * Major version changes indicate different required support level from
       * the required components.
       * </pre>
       *
       * <code>int64 major = 1 [json_name = "major"];</code>
       * @return The major.
       */
      @java.lang.Override
      public long getMajor() {
        return major_;
      }
      /**
       * <pre>
       * Major version changes indicate different required support level from
       * the required components.
       * </pre>
       *
       * <code>int64 major = 1 [json_name = "major"];</code>
       * @param value The major to set.
       */
      private void setMajor(long value) {
        
        major_ = value;
      }
      /**
       * <pre>
       * Major version changes indicate different required support level from
       * the required components.
       * </pre>
       *
       * <code>int64 major = 1 [json_name = "major"];</code>
       */
      private void clearMajor() {

        major_ = 0L;
      }

      public static final int MINOR_FIELD_NUMBER = 2;
      private long minor_;
      /**
       * <pre>
       * Minor version changes must not change the observed behavior from
       * existing implementations, but may be provided informationally.
       * </pre>
       *
       * <code>int64 minor = 2 [json_name = "minor"];</code>
       * @return The minor.
       */
      @java.lang.Override
      public long getMinor() {
        return minor_;
      }
      /**
       * <pre>
       * Minor version changes must not change the observed behavior from
       * existing implementations, but may be provided informationally.
       * </pre>
       *
       * <code>int64 minor = 2 [json_name = "minor"];</code>
       * @param value The minor to set.
       */
      private void setMinor(long value) {
        
        minor_ = value;
      }
      /**
       * <pre>
       * Minor version changes must not change the observed behavior from
       * existing implementations, but may be provided informationally.
       * </pre>
       *
       * <code>int64 minor = 2 [json_name = "minor"];</code>
       */
      private void clearMinor() {

        minor_ = 0L;
      }

      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }

      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.api.expr.v1alpha1.SourceInfo.Extension.Version prototype) {
        return DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Version
       * </pre>
       *
       * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo.Extension.Version}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.api.expr.v1alpha1.SourceInfo.Extension.Version, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.api.expr.v1alpha1.SourceInfo.Extension.Version)
          com.google.api.expr.v1alpha1.SourceInfo.Extension.VersionOrBuilder {
        // Construct using com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Major version changes indicate different required support level from
         * the required components.
         * </pre>
         *
         * <code>int64 major = 1 [json_name = "major"];</code>
         * @return The major.
         */
        @java.lang.Override
        public long getMajor() {
          return instance.getMajor();
        }
        /**
         * <pre>
         * Major version changes indicate different required support level from
         * the required components.
         * </pre>
         *
         * <code>int64 major = 1 [json_name = "major"];</code>
         * @param value The major to set.
         * @return This builder for chaining.
         */
        public Builder setMajor(long value) {
          copyOnWrite();
          instance.setMajor(value);
          return this;
        }
        /**
         * <pre>
         * Major version changes indicate different required support level from
         * the required components.
         * </pre>
         *
         * <code>int64 major = 1 [json_name = "major"];</code>
         * @return This builder for chaining.
         */
        public Builder clearMajor() {
          copyOnWrite();
          instance.clearMajor();
          return this;
        }

        /**
         * <pre>
         * Minor version changes must not change the observed behavior from
         * existing implementations, but may be provided informationally.
         * </pre>
         *
         * <code>int64 minor = 2 [json_name = "minor"];</code>
         * @return The minor.
         */
        @java.lang.Override
        public long getMinor() {
          return instance.getMinor();
        }
        /**
         * <pre>
         * Minor version changes must not change the observed behavior from
         * existing implementations, but may be provided informationally.
         * </pre>
         *
         * <code>int64 minor = 2 [json_name = "minor"];</code>
         * @param value The minor to set.
         * @return This builder for chaining.
         */
        public Builder setMinor(long value) {
          copyOnWrite();
          instance.setMinor(value);
          return this;
        }
        /**
         * <pre>
         * Minor version changes must not change the observed behavior from
         * existing implementations, but may be provided informationally.
         * </pre>
         *
         * <code>int64 minor = 2 [json_name = "minor"];</code>
         * @return This builder for chaining.
         */
        public Builder clearMinor() {
          copyOnWrite();
          instance.clearMinor();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.api.expr.v1alpha1.SourceInfo.Extension.Version)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.api.expr.v1alpha1.SourceInfo.Extension.Version();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "major_",
                "minor_",
              };
              java.lang.String info =
                  "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                  "";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.api.expr.v1alpha1.SourceInfo.Extension.Version> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.api.expr.v1alpha1.SourceInfo.Extension.Version>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.api.expr.v1alpha1.SourceInfo.Extension.Version)
      private static final com.google.api.expr.v1alpha1.SourceInfo.Extension.Version DEFAULT_INSTANCE;
      static {
        Version defaultInstance = new Version();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Version.class, defaultInstance);
      }

      public static com.google.api.expr.v1alpha1.SourceInfo.Extension.Version getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Version> PARSER;

      public static com.google.protobuf.Parser<Version> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private java.lang.String id_;
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @return The id.
     */
    @java.lang.Override
    public java.lang.String getId() {
      return id_;
    }
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @return The bytes for id.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(id_);
    }
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @param value The id to set.
     */
    private void setId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  
      id_ = value;
    }
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     */
    private void clearId() {

      id_ = getDefaultInstance().getId();
    }
    /**
     * <pre>
     * Identifier for the extension. Example: constant_folding
     * </pre>
     *
     * <code>string id = 1 [json_name = "id"];</code>
     * @param value The bytes for id to set.
     */
    private void setIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      id_ = value.toStringUtf8();

    }

    public static final int AFFECTED_COMPONENTS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.IntList affectedComponents_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> affectedComponents_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                com.google.api.expr.v1alpha1.SourceInfo.Extension.Component>() {
              @java.lang.Override
              public com.google.api.expr.v1alpha1.SourceInfo.Extension.Component convert(int from) {
                com.google.api.expr.v1alpha1.SourceInfo.Extension.Component result = com.google.api.expr.v1alpha1.SourceInfo.Extension.Component.forNumber(from);
                return result == null ? com.google.api.expr.v1alpha1.SourceInfo.Extension.Component.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return A list containing the affectedComponents.
     */
    @java.lang.Override
    public java.util.List<com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> getAffectedComponentsList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          com.google.api.expr.v1alpha1.SourceInfo.Extension.Component>(affectedComponents_, affectedComponents_converter_);
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return The count of affectedComponents.
     */
    @java.lang.Override
    public int getAffectedComponentsCount() {
      return affectedComponents_.size();
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param index The index of the element to return.
     * @return The affectedComponents at the given index.
     */
    @java.lang.Override
    public com.google.api.expr.v1alpha1.SourceInfo.Extension.Component getAffectedComponents(int index) {
      com.google.api.expr.v1alpha1.SourceInfo.Extension.Component result = com.google.api.expr.v1alpha1.SourceInfo.Extension.Component.forNumber(affectedComponents_.getInt(index));
      return result == null ? com.google.api.expr.v1alpha1.SourceInfo.Extension.Component.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @return A list containing the enum numeric values on the wire for affectedComponents.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
    getAffectedComponentsValueList() {
      return affectedComponents_;
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param index The index of the value to return.
     * @return The enum numeric value on the wire of affectedComponents at the given index.
     */
    @java.lang.Override
    public int getAffectedComponentsValue(int index) {
      return affectedComponents_.getInt(index);
    }
    private int affectedComponentsMemoizedSerializedSize;
    private void ensureAffectedComponentsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = affectedComponents_;
      if (!tmp.isModifiable()) {
        affectedComponents_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param index The index to set the value at.
     * @param value The affectedComponents to set.
     */
    private void setAffectedComponents(
        int index, com.google.api.expr.v1alpha1.SourceInfo.Extension.Component value) {
      value.getClass();
  ensureAffectedComponentsIsMutable();
      affectedComponents_.setInt(index, value.getNumber());
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param value The affectedComponents to add.
     */
    private void addAffectedComponents(com.google.api.expr.v1alpha1.SourceInfo.Extension.Component value) {
      value.getClass();
  ensureAffectedComponentsIsMutable();
      affectedComponents_.addInt(value.getNumber());
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param values The affectedComponents to add.
     */
    private void addAllAffectedComponents(
        java.lang.Iterable<? extends com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> values) {
      ensureAffectedComponentsIsMutable();
      for (com.google.api.expr.v1alpha1.SourceInfo.Extension.Component value : values) {
        affectedComponents_.addInt(value.getNumber());
      }
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     */
    private void clearAffectedComponents() {
      affectedComponents_ = emptyIntList();
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param value The enum numeric value on the wire for affectedComponents to set.
     */
    private void setAffectedComponentsValue(
        int index, int value) {
      ensureAffectedComponentsIsMutable();
      affectedComponents_.setInt(index, value);
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param value The enum numeric value on the wire for affectedComponents to add.
     */
    private void addAffectedComponentsValue(int value) {
      ensureAffectedComponentsIsMutable();
      affectedComponents_.addInt(value);
    }
    /**
     * <pre>
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
     * @param values The enum numeric values on the wire for affectedComponents to add.
     */
    private void addAllAffectedComponentsValue(
        java.lang.Iterable<java.lang.Integer> values) {
      ensureAffectedComponentsIsMutable();
      for (int value : values) {
        affectedComponents_.addInt(value);
      }
    }

    public static final int VERSION_FIELD_NUMBER = 3;
    private com.google.api.expr.v1alpha1.SourceInfo.Extension.Version version_;
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     */
    @java.lang.Override
    public com.google.api.expr.v1alpha1.SourceInfo.Extension.Version getVersion() {
      return version_ == null ? com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.getDefaultInstance() : version_;
    }
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     */
    private void setVersion(com.google.api.expr.v1alpha1.SourceInfo.Extension.Version value) {
      value.getClass();
  version_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeVersion(com.google.api.expr.v1alpha1.SourceInfo.Extension.Version value) {
      value.getClass();
  if (version_ != null &&
          version_ != com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.getDefaultInstance()) {
        version_ =
          com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.newBuilder(version_).mergeFrom(value).buildPartial();
      } else {
        version_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     * </pre>
     *
     * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
     */
    private void clearVersion() {  version_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }

    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.expr.v1alpha1.SourceInfo.Extension parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.api.expr.v1alpha1.SourceInfo.Extension prototype) {
      return DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * An extension that was requested for the source expression.
     * </pre>
     *
     * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo.Extension}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.api.expr.v1alpha1.SourceInfo.Extension, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.api.expr.v1alpha1.SourceInfo.Extension)
        com.google.api.expr.v1alpha1.SourceInfo.ExtensionOrBuilder {
      // Construct using com.google.api.expr.v1alpha1.SourceInfo.Extension.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Identifier for the extension. Example: constant_folding
       * </pre>
       *
       * <code>string id = 1 [json_name = "id"];</code>
       * @return The id.
       */
      @java.lang.Override
      public java.lang.String getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Identifier for the extension. Example: constant_folding
       * </pre>
       *
       * <code>string id = 1 [json_name = "id"];</code>
       * @return The bytes for id.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdBytes() {
        return instance.getIdBytes();
      }
      /**
       * <pre>
       * Identifier for the extension. Example: constant_folding
       * </pre>
       *
       * <code>string id = 1 [json_name = "id"];</code>
       * @param value The id to set.
       * @return This builder for chaining.
       */
      public Builder setId(
          java.lang.String value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Identifier for the extension. Example: constant_folding
       * </pre>
       *
       * <code>string id = 1 [json_name = "id"];</code>
       * @return This builder for chaining.
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }
      /**
       * <pre>
       * Identifier for the extension. Example: constant_folding
       * </pre>
       *
       * <code>string id = 1 [json_name = "id"];</code>
       * @param value The bytes for id to set.
       * @return This builder for chaining.
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @return A list containing the affectedComponents.
       */
      @java.lang.Override
      public java.util.List<com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> getAffectedComponentsList() {
        return instance.getAffectedComponentsList();
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @return The count of affectedComponents.
       */
      @java.lang.Override
      public int getAffectedComponentsCount() {
        return instance.getAffectedComponentsCount();
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param index The index of the element to return.
       * @return The affectedComponents at the given index.
       */
      @java.lang.Override
      public com.google.api.expr.v1alpha1.SourceInfo.Extension.Component getAffectedComponents(int index) {
        return instance.getAffectedComponents(index);
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param index The index to set the value at.
       * @param value The affectedComponents to set.
       * @return This builder for chaining.
       */
      public Builder setAffectedComponents(
          int index, com.google.api.expr.v1alpha1.SourceInfo.Extension.Component value) {
        copyOnWrite();
        instance.setAffectedComponents(index, value);
        return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param value The affectedComponents to add.
       * @return This builder for chaining.
       */
      public Builder addAffectedComponents(com.google.api.expr.v1alpha1.SourceInfo.Extension.Component value) {
        copyOnWrite();
        instance.addAffectedComponents(value);
        return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param values The affectedComponents to add.
       * @return This builder for chaining.
       */
      public Builder addAllAffectedComponents(
          java.lang.Iterable<? extends com.google.api.expr.v1alpha1.SourceInfo.Extension.Component> values) {
        copyOnWrite();
        instance.addAllAffectedComponents(values);  return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @return This builder for chaining.
       */
      public Builder clearAffectedComponents() {
        copyOnWrite();
        instance.clearAffectedComponents();
        return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @return A list containing the enum numeric values on the wire for affectedComponents.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
      getAffectedComponentsValueList() {
        return java.util.Collections.unmodifiableList(
            instance.getAffectedComponentsValueList());
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param index The index of the value to return.
       * @return The enum numeric value on the wire of affectedComponents at the given index.
       */
      @java.lang.Override
      public int getAffectedComponentsValue(int index) {
        return instance.getAffectedComponentsValue(index);
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param index The index to set the value at.
       * @param value The enum numeric value on the wire for affectedComponents to set.
       * @return This builder for chaining.
       */
      public Builder setAffectedComponentsValue(
          int index, int value) {
        copyOnWrite();
        instance.setAffectedComponentsValue(index, value);
        return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param value The enum numeric value on the wire for affectedComponents to add.
       * @return This builder for chaining.
       */
      public Builder addAffectedComponentsValue(int value) {
        copyOnWrite();
        instance.addAffectedComponentsValue(value);
        return this;
      }
      /**
       * <pre>
       * If set, the listed components must understand the extension for the
       * expression to evaluate correctly.
       *
       * This field has set semantics, repeated values should be deduplicated.
       * </pre>
       *
       * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2 [json_name = "affectedComponents"];</code>
       * @param values The enum numeric values on the wire for affectedComponents to add.
       * @return This builder for chaining.
       */
      public Builder addAllAffectedComponentsValue(
          java.lang.Iterable<java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllAffectedComponentsValue(values);
        return this;
      }

      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      @java.lang.Override
      public boolean hasVersion() {
        return instance.hasVersion();
      }
      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      @java.lang.Override
      public com.google.api.expr.v1alpha1.SourceInfo.Extension.Version getVersion() {
        return instance.getVersion();
      }
      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      public Builder setVersion(com.google.api.expr.v1alpha1.SourceInfo.Extension.Version value) {
        copyOnWrite();
        instance.setVersion(value);
        return this;
        }
      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      public Builder setVersion(
          com.google.api.expr.v1alpha1.SourceInfo.Extension.Version.Builder builderForValue) {
        copyOnWrite();
        instance.setVersion(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      public Builder mergeVersion(com.google.api.expr.v1alpha1.SourceInfo.Extension.Version value) {
        copyOnWrite();
        instance.mergeVersion(value);
        return this;
      }
      /**
       * <pre>
       * Version info. May be skipped if it isn't meaningful for the extension.
       * (for example constant_folding might always be v0.0).
       * </pre>
       *
       * <code>.google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3 [json_name = "version"];</code>
       */
      public Builder clearVersion() {  copyOnWrite();
        instance.clearVersion();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.api.expr.v1alpha1.SourceInfo.Extension)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.api.expr.v1alpha1.SourceInfo.Extension();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "id_",
              "affectedComponents_",
              "version_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0001\u0000\u0001\u0208\u0002,\u0003" +
                "\u1009\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.api.expr.v1alpha1.SourceInfo.Extension> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.api.expr.v1alpha1.SourceInfo.Extension.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.api.expr.v1alpha1.SourceInfo.Extension>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.api.expr.v1alpha1.SourceInfo.Extension)
    private static final com.google.api.expr.v1alpha1.SourceInfo.Extension DEFAULT_INSTANCE;
    static {
      Extension defaultInstance = new Extension();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Extension.class, defaultInstance);
    }

    public static com.google.api.expr.v1alpha1.SourceInfo.Extension getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Extension> PARSER;

    public static com.google.protobuf.Parser<Extension> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public static final int SYNTAX_VERSION_FIELD_NUMBER = 1;
  private java.lang.String syntaxVersion_;
  /**
   * <pre>
   * The syntax version of the source, e.g. `cel1`.
   * </pre>
   *
   * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
   * @return The syntaxVersion.
   */
  @java.lang.Override
  public java.lang.String getSyntaxVersion() {
    return syntaxVersion_;
  }
  /**
   * <pre>
   * The syntax version of the source, e.g. `cel1`.
   * </pre>
   *
   * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
   * @return The bytes for syntaxVersion.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSyntaxVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(syntaxVersion_);
  }
  /**
   * <pre>
   * The syntax version of the source, e.g. `cel1`.
   * </pre>
   *
   * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
   * @param value The syntaxVersion to set.
   */
  private void setSyntaxVersion(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    syntaxVersion_ = value;
  }
  /**
   * <pre>
   * The syntax version of the source, e.g. `cel1`.
   * </pre>
   *
   * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
   */
  private void clearSyntaxVersion() {

    syntaxVersion_ = getDefaultInstance().getSyntaxVersion();
  }
  /**
   * <pre>
   * The syntax version of the source, e.g. `cel1`.
   * </pre>
   *
   * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
   * @param value The bytes for syntaxVersion to set.
   */
  private void setSyntaxVersionBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    syntaxVersion_ = value.toStringUtf8();

  }

  public static final int LOCATION_FIELD_NUMBER = 2;
  private java.lang.String location_;
  /**
   * <pre>
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   * </pre>
   *
   * <code>string location = 2 [json_name = "location"];</code>
   * @return The location.
   */
  @java.lang.Override
  public java.lang.String getLocation() {
    return location_;
  }
  /**
   * <pre>
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   * </pre>
   *
   * <code>string location = 2 [json_name = "location"];</code>
   * @return The bytes for location.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getLocationBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(location_);
  }
  /**
   * <pre>
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   * </pre>
   *
   * <code>string location = 2 [json_name = "location"];</code>
   * @param value The location to set.
   */
  private void setLocation(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    location_ = value;
  }
  /**
   * <pre>
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   * </pre>
   *
   * <code>string location = 2 [json_name = "location"];</code>
   */
  private void clearLocation() {

    location_ = getDefaultInstance().getLocation();
  }
  /**
   * <pre>
   * The location name. All position information attached to an expression is
   * relative to this location.
   *
   * The location could be a file, UI element, or similar. For example,
   * `acme/app/AnvilPolicy.cel`.
   * </pre>
   *
   * <code>string location = 2 [json_name = "location"];</code>
   * @param value The bytes for location to set.
   */
  private void setLocationBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    location_ = value.toStringUtf8();

  }

  public static final int LINE_OFFSETS_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.IntList lineOffsets_;
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @return A list containing the lineOffsets.
   */
  @java.lang.Override
  public java.util.List<java.lang.Integer>
      getLineOffsetsList() {
    return lineOffsets_;
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @return The count of lineOffsets.
   */
  @java.lang.Override
  public int getLineOffsetsCount() {
    return lineOffsets_.size();
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @param index The index of the element to return.
   * @return The lineOffsets at the given index.
   */
  @java.lang.Override
  public int getLineOffsets(int index) {
    return lineOffsets_.getInt(index);
  }
  private int lineOffsetsMemoizedSerializedSize = -1;
  private void ensureLineOffsetsIsMutable() {
    com.google.protobuf.Internal.IntList tmp = lineOffsets_;
    if (!tmp.isModifiable()) {
      lineOffsets_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @param index The index to set the value at.
   * @param value The lineOffsets to set.
   */
  private void setLineOffsets(
      int index, int value) {
    ensureLineOffsetsIsMutable();
    lineOffsets_.setInt(index, value);
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @param value The lineOffsets to add.
   */
  private void addLineOffsets(int value) {
    ensureLineOffsetsIsMutable();
    lineOffsets_.addInt(value);
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   * @param values The lineOffsets to add.
   */
  private void addAllLineOffsets(
      java.lang.Iterable<? extends java.lang.Integer> values) {
    ensureLineOffsetsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, lineOffsets_);
  }
  /**
   * <pre>
   * Monotonically increasing list of code point offsets where newlines
   * `&#92;n` appear.
   *
   * The line number of a given position is the index `i` where for a given
   * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
   * column may be derivd from `id_positions[id] - line_offsets[i]`.
   * </pre>
   *
   * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
   */
  private void clearLineOffsets() {
    lineOffsets_ = emptyIntList();
  }

  public static final int POSITIONS_FIELD_NUMBER = 4;
  private static final class PositionsDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.Long, java.lang.Integer> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.Long, java.lang.Integer>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.INT64,
                0L,
                com.google.protobuf.WireFormat.FieldType.INT32,
                0);
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.Long, java.lang.Integer> positions_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.Long, java.lang.Integer>
  internalGetPositions() {
    return positions_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.Long, java.lang.Integer>
  internalGetMutablePositions() {
    if (!positions_.isMutable()) {
      positions_ = positions_.mutableCopy();
    }
    return positions_;
  }
  @java.lang.Override

  public int getPositionsCount() {
    return internalGetPositions().size();
  }
  /**
   * <pre>
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   * </pre>
   *
   * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
   */
  @java.lang.Override

  public boolean containsPositions(
      long key) {

    return internalGetPositions().containsKey(key);
  }
  /**
   * Use {@link #getPositionsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, java.lang.Integer> getPositions() {
    return getPositionsMap();
  }
  /**
   * <pre>
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   * </pre>
   *
   * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.Long, java.lang.Integer> getPositionsMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetPositions());
  }
  /**
   * <pre>
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   * </pre>
   *
   * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
   */
  @java.lang.Override

  public int getPositionsOrDefault(
      long key,
      int defaultValue) {

    java.util.Map<java.lang.Long, java.lang.Integer> map =
        internalGetPositions();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   * </pre>
   *
   * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
   */
  @java.lang.Override

  public int getPositionsOrThrow(
      long key) {

    java.util.Map<java.lang.Long, java.lang.Integer> map =
        internalGetPositions();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * A map from the parse node id (e.g. `Expr.id`) to the code point offset
   * within the source.
   * </pre>
   *
   * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
   */
  private java.util.Map<java.lang.Long, java.lang.Integer>
  getMutablePositionsMap() {
    return internalGetMutablePositions();
  }

  public static final int MACRO_CALLS_FIELD_NUMBER = 5;
  private static final class MacroCallsDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.Long, com.google.api.expr.v1alpha1.Expr> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.Long, com.google.api.expr.v1alpha1.Expr>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.INT64,
                0L,
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.api.expr.v1alpha1.Expr.getDefaultInstance());
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.Long, com.google.api.expr.v1alpha1.Expr> macroCalls_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Expr>
  internalGetMacroCalls() {
    return macroCalls_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.Long, com.google.api.expr.v1alpha1.Expr>
  internalGetMutableMacroCalls() {
    if (!macroCalls_.isMutable()) {
      macroCalls_ = macroCalls_.mutableCopy();
    }
    return macroCalls_;
  }
  @java.lang.Override

  public int getMacroCallsCount() {
    return internalGetMacroCalls().size();
  }
  /**
   * <pre>
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
   */
  @java.lang.Override

  public boolean containsMacroCalls(
      long key) {

    return internalGetMacroCalls().containsKey(key);
  }
  /**
   * Use {@link #getMacroCallsMap()} instead.
   */
  @java.lang.Override
  @java.lang.Deprecated
  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> getMacroCalls() {
    return getMacroCallsMap();
  }
  /**
   * <pre>
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
   */
  @java.lang.Override

  public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> getMacroCallsMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetMacroCalls());
  }
  /**
   * <pre>
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
   */
  @java.lang.Override

  public /* nullable */
com.google.api.expr.v1alpha1.Expr getMacroCallsOrDefault(
      long key,
      /* nullable */
com.google.api.expr.v1alpha1.Expr defaultValue) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> map =
        internalGetMacroCalls();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
   */
  @java.lang.Override

  public com.google.api.expr.v1alpha1.Expr getMacroCallsOrThrow(
      long key) {

    java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> map =
        internalGetMacroCalls();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * A map from the parse node id where a macro replacement was made to the
   * call `Expr` that resulted in a macro expansion.
   *
   * For example, `has(value.field)` is a function call that is replaced by a
   * `test_only` field selection in the AST. Likewise, the call
   * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
   * in the map corresponds to the expression id of the expanded macro, and the
   * value is the call `Expr` that was replaced.
   * </pre>
   *
   * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
   */
  private java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr>
  getMutableMacroCallsMap() {
    return internalGetMutableMacroCalls();
  }

  public static final int EXTENSIONS_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.ProtobufList<com.google.api.expr.v1alpha1.SourceInfo.Extension> extensions_;
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  @java.lang.Override
  public java.util.List<com.google.api.expr.v1alpha1.SourceInfo.Extension> getExtensionsList() {
    return extensions_;
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  public java.util.List<? extends com.google.api.expr.v1alpha1.SourceInfo.ExtensionOrBuilder> 
      getExtensionsOrBuilderList() {
    return extensions_;
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  @java.lang.Override
  public int getExtensionsCount() {
    return extensions_.size();
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  @java.lang.Override
  public com.google.api.expr.v1alpha1.SourceInfo.Extension getExtensions(int index) {
    return extensions_.get(index);
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  public com.google.api.expr.v1alpha1.SourceInfo.ExtensionOrBuilder getExtensionsOrBuilder(
      int index) {
    return extensions_.get(index);
  }
  private void ensureExtensionsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<com.google.api.expr.v1alpha1.SourceInfo.Extension> tmp = extensions_;
    if (!tmp.isModifiable()) {
      extensions_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void setExtensions(
      int index, com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
    value.getClass();
  ensureExtensionsIsMutable();
    extensions_.set(index, value);
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void addExtensions(com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
    value.getClass();
  ensureExtensionsIsMutable();
    extensions_.add(value);
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void addExtensions(
      int index, com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
    value.getClass();
  ensureExtensionsIsMutable();
    extensions_.add(index, value);
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void addAllExtensions(
      java.lang.Iterable<? extends com.google.api.expr.v1alpha1.SourceInfo.Extension> values) {
    ensureExtensionsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, extensions_);
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void clearExtensions() {
    extensions_ = emptyProtobufList();
  }
  /**
   * <pre>
   * A list of tags for extensions that were used while parsing or type checking
   * the source expression. For example, optimizations that require special
   * runtime support may be specified.
   *
   * These are used to check feature support between components in separate
   * implementations. This can be used to either skip redundant work or
   * report an error if the extension is unsupported.
   * </pre>
   *
   * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
   */
  private void removeExtensions(int index) {
    ensureExtensionsIsMutable();
    extensions_.remove(index);
  }

  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static com.google.api.expr.v1alpha1.SourceInfo parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.api.expr.v1alpha1.SourceInfo parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.expr.v1alpha1.SourceInfo parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(com.google.api.expr.v1alpha1.SourceInfo prototype) {
    return DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Source information collected at parse time.
   * </pre>
   *
   * Protobuf type {@code google.api.expr.v1alpha1.SourceInfo}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.api.expr.v1alpha1.SourceInfo, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.api.expr.v1alpha1.SourceInfo)
      com.google.api.expr.v1alpha1.SourceInfoOrBuilder {
    // Construct using com.google.api.expr.v1alpha1.SourceInfo.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The syntax version of the source, e.g. `cel1`.
     * </pre>
     *
     * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
     * @return The syntaxVersion.
     */
    @java.lang.Override
    public java.lang.String getSyntaxVersion() {
      return instance.getSyntaxVersion();
    }
    /**
     * <pre>
     * The syntax version of the source, e.g. `cel1`.
     * </pre>
     *
     * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
     * @return The bytes for syntaxVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSyntaxVersionBytes() {
      return instance.getSyntaxVersionBytes();
    }
    /**
     * <pre>
     * The syntax version of the source, e.g. `cel1`.
     * </pre>
     *
     * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
     * @param value The syntaxVersion to set.
     * @return This builder for chaining.
     */
    public Builder setSyntaxVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setSyntaxVersion(value);
      return this;
    }
    /**
     * <pre>
     * The syntax version of the source, e.g. `cel1`.
     * </pre>
     *
     * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSyntaxVersion() {
      copyOnWrite();
      instance.clearSyntaxVersion();
      return this;
    }
    /**
     * <pre>
     * The syntax version of the source, e.g. `cel1`.
     * </pre>
     *
     * <code>string syntax_version = 1 [json_name = "syntaxVersion"];</code>
     * @param value The bytes for syntaxVersion to set.
     * @return This builder for chaining.
     */
    public Builder setSyntaxVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSyntaxVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     * </pre>
     *
     * <code>string location = 2 [json_name = "location"];</code>
     * @return The location.
     */
    @java.lang.Override
    public java.lang.String getLocation() {
      return instance.getLocation();
    }
    /**
     * <pre>
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     * </pre>
     *
     * <code>string location = 2 [json_name = "location"];</code>
     * @return The bytes for location.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLocationBytes() {
      return instance.getLocationBytes();
    }
    /**
     * <pre>
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     * </pre>
     *
     * <code>string location = 2 [json_name = "location"];</code>
     * @param value The location to set.
     * @return This builder for chaining.
     */
    public Builder setLocation(
        java.lang.String value) {
      copyOnWrite();
      instance.setLocation(value);
      return this;
    }
    /**
     * <pre>
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     * </pre>
     *
     * <code>string location = 2 [json_name = "location"];</code>
     * @return This builder for chaining.
     */
    public Builder clearLocation() {
      copyOnWrite();
      instance.clearLocation();
      return this;
    }
    /**
     * <pre>
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     * </pre>
     *
     * <code>string location = 2 [json_name = "location"];</code>
     * @param value The bytes for location to set.
     * @return This builder for chaining.
     */
    public Builder setLocationBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLocationBytes(value);
      return this;
    }

    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @return A list containing the lineOffsets.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getLineOffsetsList() {
      return java.util.Collections.unmodifiableList(
          instance.getLineOffsetsList());
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @return The count of lineOffsets.
     */
    @java.lang.Override
    public int getLineOffsetsCount() {
      return instance.getLineOffsetsCount();
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @param index The index of the element to return.
     * @return The lineOffsets at the given index.
     */
    @java.lang.Override
    public int getLineOffsets(int index) {
      return instance.getLineOffsets(index);
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @param value The lineOffsets to set.
     * @return This builder for chaining.
     */
    public Builder setLineOffsets(
        int index, int value) {
      copyOnWrite();
      instance.setLineOffsets(index, value);
      return this;
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @param value The lineOffsets to add.
     * @return This builder for chaining.
     */
    public Builder addLineOffsets(int value) {
      copyOnWrite();
      instance.addLineOffsets(value);
      return this;
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @param values The lineOffsets to add.
     * @return This builder for chaining.
     */
    public Builder addAllLineOffsets(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      copyOnWrite();
      instance.addAllLineOffsets(values);
      return this;
    }
    /**
     * <pre>
     * Monotonically increasing list of code point offsets where newlines
     * `&#92;n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] &lt; id_positions[id] &lt; line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     * </pre>
     *
     * <code>repeated int32 line_offsets = 3 [json_name = "lineOffsets"];</code>
     * @return This builder for chaining.
     */
    public Builder clearLineOffsets() {
      copyOnWrite();
      instance.clearLineOffsets();
      return this;
    }

    @java.lang.Override

    public int getPositionsCount() {
      return instance.getPositionsMap().size();
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    @java.lang.Override

    public boolean containsPositions(
        long key) {

      return instance.getPositionsMap().containsKey(key);
    }

    public Builder clearPositions() {
      copyOnWrite();
      instance.getMutablePositionsMap().clear();
      return this;
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */

    public Builder removePositions(
        long key) {

      copyOnWrite();
      instance.getMutablePositionsMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getPositionsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.Integer> getPositions() {
      return getPositionsMap();
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, java.lang.Integer> getPositionsMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getPositionsMap());
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    @java.lang.Override

    public int getPositionsOrDefault(
        long key,
        int defaultValue) {

      java.util.Map<java.lang.Long, java.lang.Integer> map =
          instance.getPositionsMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    @java.lang.Override

    public int getPositionsOrThrow(
        long key) {

      java.util.Map<java.lang.Long, java.lang.Integer> map =
          instance.getPositionsMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    public Builder putPositions(
        long key,
        int value) {


      copyOnWrite();
      instance.getMutablePositionsMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; positions = 4 [json_name = "positions"];</code>
     */
    public Builder putAllPositions(
        java.util.Map<java.lang.Long, java.lang.Integer> values) {
      copyOnWrite();
      instance.getMutablePositionsMap().putAll(values);
      return this;
    }

    @java.lang.Override

    public int getMacroCallsCount() {
      return instance.getMacroCallsMap().size();
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    @java.lang.Override

    public boolean containsMacroCalls(
        long key) {

      return instance.getMacroCallsMap().containsKey(key);
    }

    public Builder clearMacroCalls() {
      copyOnWrite();
      instance.getMutableMacroCallsMap().clear();
      return this;
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */

    public Builder removeMacroCalls(
        long key) {

      copyOnWrite();
      instance.getMutableMacroCallsMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getMacroCallsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> getMacroCalls() {
      return getMacroCallsMap();
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> getMacroCallsMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getMacroCallsMap());
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    @java.lang.Override

    public /* nullable */
com.google.api.expr.v1alpha1.Expr getMacroCallsOrDefault(
        long key,
        /* nullable */
com.google.api.expr.v1alpha1.Expr defaultValue) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> map =
          instance.getMacroCallsMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    @java.lang.Override

    public com.google.api.expr.v1alpha1.Expr getMacroCallsOrThrow(
        long key) {

      java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> map =
          instance.getMacroCallsMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    public Builder putMacroCalls(
        long key,
        com.google.api.expr.v1alpha1.Expr value) {

      java.lang.Class<?> valueClass = value.getClass();
      copyOnWrite();
      instance.getMutableMacroCallsMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e &gt; 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     * </pre>
     *
     * <code>map&lt;int64, .google.api.expr.v1alpha1.Expr&gt; macro_calls = 5 [json_name = "macroCalls"];</code>
     */
    public Builder putAllMacroCalls(
        java.util.Map<java.lang.Long, com.google.api.expr.v1alpha1.Expr> values) {
      copyOnWrite();
      instance.getMutableMacroCallsMap().putAll(values);
      return this;
    }

    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    @java.lang.Override
    public java.util.List<com.google.api.expr.v1alpha1.SourceInfo.Extension> getExtensionsList() {
      return java.util.Collections.unmodifiableList(
          instance.getExtensionsList());
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    @java.lang.Override
    public int getExtensionsCount() {
      return instance.getExtensionsCount();
    }/**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    @java.lang.Override
    public com.google.api.expr.v1alpha1.SourceInfo.Extension getExtensions(int index) {
      return instance.getExtensions(index);
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder setExtensions(
        int index, com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
      copyOnWrite();
      instance.setExtensions(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder setExtensions(
        int index, com.google.api.expr.v1alpha1.SourceInfo.Extension.Builder builderForValue) {
      copyOnWrite();
      instance.setExtensions(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder addExtensions(com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
      copyOnWrite();
      instance.addExtensions(value);
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder addExtensions(
        int index, com.google.api.expr.v1alpha1.SourceInfo.Extension value) {
      copyOnWrite();
      instance.addExtensions(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder addExtensions(
        com.google.api.expr.v1alpha1.SourceInfo.Extension.Builder builderForValue) {
      copyOnWrite();
      instance.addExtensions(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder addExtensions(
        int index, com.google.api.expr.v1alpha1.SourceInfo.Extension.Builder builderForValue) {
      copyOnWrite();
      instance.addExtensions(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder addAllExtensions(
        java.lang.Iterable<? extends com.google.api.expr.v1alpha1.SourceInfo.Extension> values) {
      copyOnWrite();
      instance.addAllExtensions(values);
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder clearExtensions() {
      copyOnWrite();
      instance.clearExtensions();
      return this;
    }
    /**
     * <pre>
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     * </pre>
     *
     * <code>repeated .google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6 [json_name = "extensions"];</code>
     */
    public Builder removeExtensions(int index) {
      copyOnWrite();
      instance.removeExtensions(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.api.expr.v1alpha1.SourceInfo)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.api.expr.v1alpha1.SourceInfo();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "syntaxVersion_",
            "location_",
            "lineOffsets_",
            "positions_",
            PositionsDefaultEntryHolder.defaultEntry,
            "macroCalls_",
            MacroCallsDefaultEntryHolder.defaultEntry,
            "extensions_",
            com.google.api.expr.v1alpha1.SourceInfo.Extension.class,
          };
          java.lang.String info =
              "\u0000\u0006\u0000\u0000\u0001\u0006\u0006\u0002\u0002\u0000\u0001\u0208\u0002\u0208" +
              "\u0003\'\u00042\u00052\u0006\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<com.google.api.expr.v1alpha1.SourceInfo> parser = PARSER;
        if (parser == null) {
          synchronized (com.google.api.expr.v1alpha1.SourceInfo.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<com.google.api.expr.v1alpha1.SourceInfo>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.api.expr.v1alpha1.SourceInfo)
  private static final com.google.api.expr.v1alpha1.SourceInfo DEFAULT_INSTANCE;
  static {
    SourceInfo defaultInstance = new SourceInfo();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      SourceInfo.class, defaultInstance);
  }

  public static com.google.api.expr.v1alpha1.SourceInfo getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SourceInfo> PARSER;

  public static com.google.protobuf.Parser<SourceInfo> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

