// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: google/type/postal_address.proto
// Protobuf Java Version: 4.27.2

package com.google.type;

/**
 * <pre>
 * Represents a postal address, e.g. for postal delivery or payments addresses.
 * Given a postal address, a postal service can deliver items to a premise, P.O.
 * Box or similar.
 * It is not intended to model geographical locations (roads, towns,
 * mountains).
 *
 * In typical usage an address would be created via user input or from importing
 * existing data, depending on the type of process.
 *
 * Advice on address input / editing:
 * - Use an i18n-ready address widget such as
 * https://github.com/google/libaddressinput)
 * - Users should not be presented with UI elements for input or editing of
 * fields outside countries where that field is used.
 *
 * For more guidance on how to use this schema, please see:
 * https://support.google.com/business/answer/6397478
 * </pre>
 *
 * Protobuf type {@code google.type.PostalAddress}
 */
public  final class PostalAddress extends
    com.google.protobuf.GeneratedMessageLite<
        PostalAddress, PostalAddress.Builder> implements
    // @@protoc_insertion_point(message_implements:google.type.PostalAddress)
    PostalAddressOrBuilder {
  private PostalAddress() {
    regionCode_ = "";
    languageCode_ = "";
    postalCode_ = "";
    sortingCode_ = "";
    administrativeArea_ = "";
    locality_ = "";
    sublocality_ = "";
    addressLines_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    recipients_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    organization_ = "";
  }
  public static final int REVISION_FIELD_NUMBER = 1;
  private int revision_;
  /**
   * <pre>
   * The schema revision of the `PostalAddress`. This must be set to 0, which is
   * the latest revision.
   *
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>int32 revision = 1 [json_name = "revision"];</code>
   * @return The revision.
   */
  @java.lang.Override
  public int getRevision() {
    return revision_;
  }
  /**
   * <pre>
   * The schema revision of the `PostalAddress`. This must be set to 0, which is
   * the latest revision.
   *
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>int32 revision = 1 [json_name = "revision"];</code>
   * @param value The revision to set.
   */
  private void setRevision(int value) {
    
    revision_ = value;
  }
  /**
   * <pre>
   * The schema revision of the `PostalAddress`. This must be set to 0, which is
   * the latest revision.
   *
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>int32 revision = 1 [json_name = "revision"];</code>
   */
  private void clearRevision() {

    revision_ = 0;
  }

  public static final int REGION_CODE_FIELD_NUMBER = 2;
  private java.lang.String regionCode_;
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>string region_code = 2 [json_name = "regionCode"];</code>
   * @return The regionCode.
   */
  @java.lang.Override
  public java.lang.String getRegionCode() {
    return regionCode_;
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>string region_code = 2 [json_name = "regionCode"];</code>
   * @return The bytes for regionCode.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getRegionCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(regionCode_);
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>string region_code = 2 [json_name = "regionCode"];</code>
   * @param value The regionCode to set.
   */
  private void setRegionCode(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    regionCode_ = value;
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>string region_code = 2 [json_name = "regionCode"];</code>
   */
  private void clearRegionCode() {

    regionCode_ = getDefaultInstance().getRegionCode();
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>string region_code = 2 [json_name = "regionCode"];</code>
   * @param value The bytes for regionCode to set.
   */
  private void setRegionCodeBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    regionCode_ = value.toStringUtf8();

  }

  public static final int LANGUAGE_CODE_FIELD_NUMBER = 3;
  private java.lang.String languageCode_;
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   *
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   *
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>string language_code = 3 [json_name = "languageCode"];</code>
   * @return The languageCode.
   */
  @java.lang.Override
  public java.lang.String getLanguageCode() {
    return languageCode_;
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   *
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   *
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>string language_code = 3 [json_name = "languageCode"];</code>
   * @return The bytes for languageCode.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getLanguageCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(languageCode_);
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   *
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   *
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>string language_code = 3 [json_name = "languageCode"];</code>
   * @param value The languageCode to set.
   */
  private void setLanguageCode(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    languageCode_ = value;
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   *
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   *
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>string language_code = 3 [json_name = "languageCode"];</code>
   */
  private void clearLanguageCode() {

    languageCode_ = getDefaultInstance().getLanguageCode();
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   *
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   *
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>string language_code = 3 [json_name = "languageCode"];</code>
   * @param value The bytes for languageCode to set.
   */
  private void setLanguageCodeBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    languageCode_ = value.toStringUtf8();

  }

  public static final int POSTAL_CODE_FIELD_NUMBER = 4;
  private java.lang.String postalCode_;
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>string postal_code = 4 [json_name = "postalCode"];</code>
   * @return The postalCode.
   */
  @java.lang.Override
  public java.lang.String getPostalCode() {
    return postalCode_;
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>string postal_code = 4 [json_name = "postalCode"];</code>
   * @return The bytes for postalCode.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getPostalCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(postalCode_);
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>string postal_code = 4 [json_name = "postalCode"];</code>
   * @param value The postalCode to set.
   */
  private void setPostalCode(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    postalCode_ = value;
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>string postal_code = 4 [json_name = "postalCode"];</code>
   */
  private void clearPostalCode() {

    postalCode_ = getDefaultInstance().getPostalCode();
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>string postal_code = 4 [json_name = "postalCode"];</code>
   * @param value The bytes for postalCode to set.
   */
  private void setPostalCodeBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    postalCode_ = value.toStringUtf8();

  }

  public static final int SORTING_CODE_FIELD_NUMBER = 5;
  private java.lang.String sortingCode_;
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
   * @return The sortingCode.
   */
  @java.lang.Override
  public java.lang.String getSortingCode() {
    return sortingCode_;
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
   * @return The bytes for sortingCode.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSortingCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(sortingCode_);
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
   * @param value The sortingCode to set.
   */
  private void setSortingCode(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    sortingCode_ = value;
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
   */
  private void clearSortingCode() {

    sortingCode_ = getDefaultInstance().getSortingCode();
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
   * @param value The bytes for sortingCode to set.
   */
  private void setSortingCodeBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    sortingCode_ = value.toStringUtf8();

  }

  public static final int ADMINISTRATIVE_AREA_FIELD_NUMBER = 6;
  private java.lang.String administrativeArea_;
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
   * @return The administrativeArea.
   */
  @java.lang.Override
  public java.lang.String getAdministrativeArea() {
    return administrativeArea_;
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
   * @return The bytes for administrativeArea.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAdministrativeAreaBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(administrativeArea_);
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
   * @param value The administrativeArea to set.
   */
  private void setAdministrativeArea(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    administrativeArea_ = value;
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
   */
  private void clearAdministrativeArea() {

    administrativeArea_ = getDefaultInstance().getAdministrativeArea();
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
   * @param value The bytes for administrativeArea to set.
   */
  private void setAdministrativeAreaBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    administrativeArea_ = value.toStringUtf8();

  }

  public static final int LOCALITY_FIELD_NUMBER = 7;
  private java.lang.String locality_;
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>string locality = 7 [json_name = "locality"];</code>
   * @return The locality.
   */
  @java.lang.Override
  public java.lang.String getLocality() {
    return locality_;
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>string locality = 7 [json_name = "locality"];</code>
   * @return The bytes for locality.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getLocalityBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(locality_);
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>string locality = 7 [json_name = "locality"];</code>
   * @param value The locality to set.
   */
  private void setLocality(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    locality_ = value;
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>string locality = 7 [json_name = "locality"];</code>
   */
  private void clearLocality() {

    locality_ = getDefaultInstance().getLocality();
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>string locality = 7 [json_name = "locality"];</code>
   * @param value The bytes for locality to set.
   */
  private void setLocalityBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    locality_ = value.toStringUtf8();

  }

  public static final int SUBLOCALITY_FIELD_NUMBER = 8;
  private java.lang.String sublocality_;
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>string sublocality = 8 [json_name = "sublocality"];</code>
   * @return The sublocality.
   */
  @java.lang.Override
  public java.lang.String getSublocality() {
    return sublocality_;
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>string sublocality = 8 [json_name = "sublocality"];</code>
   * @return The bytes for sublocality.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getSublocalityBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(sublocality_);
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>string sublocality = 8 [json_name = "sublocality"];</code>
   * @param value The sublocality to set.
   */
  private void setSublocality(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    sublocality_ = value;
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>string sublocality = 8 [json_name = "sublocality"];</code>
   */
  private void clearSublocality() {

    sublocality_ = getDefaultInstance().getSublocality();
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>string sublocality = 8 [json_name = "sublocality"];</code>
   * @param value The bytes for sublocality to set.
   */
  private void setSublocalityBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    sublocality_ = value.toStringUtf8();

  }

  public static final int ADDRESS_LINES_FIELD_NUMBER = 9;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> addressLines_;
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @return A list containing the addressLines.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getAddressLinesList() {
    return addressLines_;
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @return The count of addressLines.
   */
  @java.lang.Override
  public int getAddressLinesCount() {
    return addressLines_.size();
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param index The index of the element to return.
   * @return The addressLines at the given index.
   */
  @java.lang.Override
  public java.lang.String getAddressLines(int index) {
    return addressLines_.get(index);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param index The index of the value to return.
   * @return The bytes of the addressLines at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getAddressLinesBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        addressLines_.get(index));
  }
  private void ensureAddressLinesIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        addressLines_;  if (!tmp.isModifiable()) {
      addressLines_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param index The index to set the value at.
   * @param value The addressLines to set.
   */
  private void setAddressLines(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureAddressLinesIsMutable();
    addressLines_.set(index, value);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param value The addressLines to add.
   */
  private void addAddressLines(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureAddressLinesIsMutable();
    addressLines_.add(value);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param values The addressLines to add.
   */
  private void addAllAddressLines(
      java.lang.Iterable<java.lang.String> values) {
    ensureAddressLinesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, addressLines_);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   */
  private void clearAddressLines() {
    addressLines_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   *
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   *
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   *
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
   * @param value The bytes of the addressLines to add.
   */
  private void addAddressLinesBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureAddressLinesIsMutable();
    addressLines_.add(value.toStringUtf8());
  }

  public static final int RECIPIENTS_FIELD_NUMBER = 10;
  private com.google.protobuf.Internal.ProtobufList<java.lang.String> recipients_;
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @return A list containing the recipients.
   */
  @java.lang.Override
  public java.util.List<java.lang.String> getRecipientsList() {
    return recipients_;
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @return The count of recipients.
   */
  @java.lang.Override
  public int getRecipientsCount() {
    return recipients_.size();
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param index The index of the element to return.
   * @return The recipients at the given index.
   */
  @java.lang.Override
  public java.lang.String getRecipients(int index) {
    return recipients_.get(index);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param index The index of the value to return.
   * @return The bytes of the recipients at the given index.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getRecipientsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        recipients_.get(index));
  }
  private void ensureRecipientsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
        recipients_;  if (!tmp.isModifiable()) {
      recipients_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param index The index to set the value at.
   * @param value The recipients to set.
   */
  private void setRecipients(
      int index, java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureRecipientsIsMutable();
    recipients_.set(index, value);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param value The recipients to add.
   */
  private void addRecipients(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  ensureRecipientsIsMutable();
    recipients_.add(value);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param values The recipients to add.
   */
  private void addAllRecipients(
      java.lang.Iterable<java.lang.String> values) {
    ensureRecipientsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, recipients_);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   */
  private void clearRecipients() {
    recipients_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
   * @param value The bytes of the recipients to add.
   */
  private void addRecipientsBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    ensureRecipientsIsMutable();
    recipients_.add(value.toStringUtf8());
  }

  public static final int ORGANIZATION_FIELD_NUMBER = 11;
  private java.lang.String organization_;
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>string organization = 11 [json_name = "organization"];</code>
   * @return The organization.
   */
  @java.lang.Override
  public java.lang.String getOrganization() {
    return organization_;
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>string organization = 11 [json_name = "organization"];</code>
   * @return The bytes for organization.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getOrganizationBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(organization_);
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>string organization = 11 [json_name = "organization"];</code>
   * @param value The organization to set.
   */
  private void setOrganization(
      java.lang.String value) {
    java.lang.Class<?> valueClass = value.getClass();
  
    organization_ = value;
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>string organization = 11 [json_name = "organization"];</code>
   */
  private void clearOrganization() {

    organization_ = getDefaultInstance().getOrganization();
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>string organization = 11 [json_name = "organization"];</code>
   * @param value The bytes for organization to set.
   */
  private void setOrganizationBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    organization_ = value.toStringUtf8();

  }

  public static com.google.type.PostalAddress parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.type.PostalAddress parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.type.PostalAddress parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.type.PostalAddress parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static com.google.type.PostalAddress parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.type.PostalAddress parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(com.google.type.PostalAddress prototype) {
    return DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Represents a postal address, e.g. for postal delivery or payments addresses.
   * Given a postal address, a postal service can deliver items to a premise, P.O.
   * Box or similar.
   * It is not intended to model geographical locations (roads, towns,
   * mountains).
   *
   * In typical usage an address would be created via user input or from importing
   * existing data, depending on the type of process.
   *
   * Advice on address input / editing:
   * - Use an i18n-ready address widget such as
   * https://github.com/google/libaddressinput)
   * - Users should not be presented with UI elements for input or editing of
   * fields outside countries where that field is used.
   *
   * For more guidance on how to use this schema, please see:
   * https://support.google.com/business/answer/6397478
   * </pre>
   *
   * Protobuf type {@code google.type.PostalAddress}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.type.PostalAddress, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.type.PostalAddress)
      com.google.type.PostalAddressOrBuilder {
    // Construct using com.google.type.PostalAddress.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The schema revision of the `PostalAddress`. This must be set to 0, which is
     * the latest revision.
     *
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>int32 revision = 1 [json_name = "revision"];</code>
     * @return The revision.
     */
    @java.lang.Override
    public int getRevision() {
      return instance.getRevision();
    }
    /**
     * <pre>
     * The schema revision of the `PostalAddress`. This must be set to 0, which is
     * the latest revision.
     *
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>int32 revision = 1 [json_name = "revision"];</code>
     * @param value The revision to set.
     * @return This builder for chaining.
     */
    public Builder setRevision(int value) {
      copyOnWrite();
      instance.setRevision(value);
      return this;
    }
    /**
     * <pre>
     * The schema revision of the `PostalAddress`. This must be set to 0, which is
     * the latest revision.
     *
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>int32 revision = 1 [json_name = "revision"];</code>
     * @return This builder for chaining.
     */
    public Builder clearRevision() {
      copyOnWrite();
      instance.clearRevision();
      return this;
    }

    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>string region_code = 2 [json_name = "regionCode"];</code>
     * @return The regionCode.
     */
    @java.lang.Override
    public java.lang.String getRegionCode() {
      return instance.getRegionCode();
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>string region_code = 2 [json_name = "regionCode"];</code>
     * @return The bytes for regionCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRegionCodeBytes() {
      return instance.getRegionCodeBytes();
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>string region_code = 2 [json_name = "regionCode"];</code>
     * @param value The regionCode to set.
     * @return This builder for chaining.
     */
    public Builder setRegionCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setRegionCode(value);
      return this;
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>string region_code = 2 [json_name = "regionCode"];</code>
     * @return This builder for chaining.
     */
    public Builder clearRegionCode() {
      copyOnWrite();
      instance.clearRegionCode();
      return this;
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>string region_code = 2 [json_name = "regionCode"];</code>
     * @param value The bytes for regionCode to set.
     * @return This builder for chaining.
     */
    public Builder setRegionCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setRegionCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     *
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     *
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>string language_code = 3 [json_name = "languageCode"];</code>
     * @return The languageCode.
     */
    @java.lang.Override
    public java.lang.String getLanguageCode() {
      return instance.getLanguageCode();
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     *
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     *
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>string language_code = 3 [json_name = "languageCode"];</code>
     * @return The bytes for languageCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLanguageCodeBytes() {
      return instance.getLanguageCodeBytes();
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     *
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     *
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>string language_code = 3 [json_name = "languageCode"];</code>
     * @param value The languageCode to set.
     * @return This builder for chaining.
     */
    public Builder setLanguageCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setLanguageCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     *
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     *
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>string language_code = 3 [json_name = "languageCode"];</code>
     * @return This builder for chaining.
     */
    public Builder clearLanguageCode() {
      copyOnWrite();
      instance.clearLanguageCode();
      return this;
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     *
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     *
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>string language_code = 3 [json_name = "languageCode"];</code>
     * @param value The bytes for languageCode to set.
     * @return This builder for chaining.
     */
    public Builder setLanguageCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLanguageCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>string postal_code = 4 [json_name = "postalCode"];</code>
     * @return The postalCode.
     */
    @java.lang.Override
    public java.lang.String getPostalCode() {
      return instance.getPostalCode();
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>string postal_code = 4 [json_name = "postalCode"];</code>
     * @return The bytes for postalCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPostalCodeBytes() {
      return instance.getPostalCodeBytes();
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>string postal_code = 4 [json_name = "postalCode"];</code>
     * @param value The postalCode to set.
     * @return This builder for chaining.
     */
    public Builder setPostalCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setPostalCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>string postal_code = 4 [json_name = "postalCode"];</code>
     * @return This builder for chaining.
     */
    public Builder clearPostalCode() {
      copyOnWrite();
      instance.clearPostalCode();
      return this;
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>string postal_code = 4 [json_name = "postalCode"];</code>
     * @param value The bytes for postalCode to set.
     * @return This builder for chaining.
     */
    public Builder setPostalCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setPostalCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
     * @return The sortingCode.
     */
    @java.lang.Override
    public java.lang.String getSortingCode() {
      return instance.getSortingCode();
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
     * @return The bytes for sortingCode.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSortingCodeBytes() {
      return instance.getSortingCodeBytes();
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
     * @param value The sortingCode to set.
     * @return This builder for chaining.
     */
    public Builder setSortingCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setSortingCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSortingCode() {
      copyOnWrite();
      instance.clearSortingCode();
      return this;
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>string sorting_code = 5 [json_name = "sortingCode"];</code>
     * @param value The bytes for sortingCode to set.
     * @return This builder for chaining.
     */
    public Builder setSortingCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSortingCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
     * @return The administrativeArea.
     */
    @java.lang.Override
    public java.lang.String getAdministrativeArea() {
      return instance.getAdministrativeArea();
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
     * @return The bytes for administrativeArea.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAdministrativeAreaBytes() {
      return instance.getAdministrativeAreaBytes();
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
     * @param value The administrativeArea to set.
     * @return This builder for chaining.
     */
    public Builder setAdministrativeArea(
        java.lang.String value) {
      copyOnWrite();
      instance.setAdministrativeArea(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
     * @return This builder for chaining.
     */
    public Builder clearAdministrativeArea() {
      copyOnWrite();
      instance.clearAdministrativeArea();
      return this;
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>string administrative_area = 6 [json_name = "administrativeArea"];</code>
     * @param value The bytes for administrativeArea to set.
     * @return This builder for chaining.
     */
    public Builder setAdministrativeAreaBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setAdministrativeAreaBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>string locality = 7 [json_name = "locality"];</code>
     * @return The locality.
     */
    @java.lang.Override
    public java.lang.String getLocality() {
      return instance.getLocality();
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>string locality = 7 [json_name = "locality"];</code>
     * @return The bytes for locality.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLocalityBytes() {
      return instance.getLocalityBytes();
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>string locality = 7 [json_name = "locality"];</code>
     * @param value The locality to set.
     * @return This builder for chaining.
     */
    public Builder setLocality(
        java.lang.String value) {
      copyOnWrite();
      instance.setLocality(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>string locality = 7 [json_name = "locality"];</code>
     * @return This builder for chaining.
     */
    public Builder clearLocality() {
      copyOnWrite();
      instance.clearLocality();
      return this;
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>string locality = 7 [json_name = "locality"];</code>
     * @param value The bytes for locality to set.
     * @return This builder for chaining.
     */
    public Builder setLocalityBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLocalityBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>string sublocality = 8 [json_name = "sublocality"];</code>
     * @return The sublocality.
     */
    @java.lang.Override
    public java.lang.String getSublocality() {
      return instance.getSublocality();
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>string sublocality = 8 [json_name = "sublocality"];</code>
     * @return The bytes for sublocality.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSublocalityBytes() {
      return instance.getSublocalityBytes();
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>string sublocality = 8 [json_name = "sublocality"];</code>
     * @param value The sublocality to set.
     * @return This builder for chaining.
     */
    public Builder setSublocality(
        java.lang.String value) {
      copyOnWrite();
      instance.setSublocality(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>string sublocality = 8 [json_name = "sublocality"];</code>
     * @return This builder for chaining.
     */
    public Builder clearSublocality() {
      copyOnWrite();
      instance.clearSublocality();
      return this;
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>string sublocality = 8 [json_name = "sublocality"];</code>
     * @param value The bytes for sublocality to set.
     * @return This builder for chaining.
     */
    public Builder setSublocalityBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSublocalityBytes(value);
      return this;
    }

    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @return A list containing the addressLines.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getAddressLinesList() {
      return java.util.Collections.unmodifiableList(
          instance.getAddressLinesList());
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @return The count of addressLines.
     */
    @java.lang.Override
    public int getAddressLinesCount() {
      return instance.getAddressLinesCount();
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param index The index of the element to return.
     * @return The addressLines at the given index.
     */
    @java.lang.Override
    public java.lang.String getAddressLines(int index) {
      return instance.getAddressLines(index);
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the addressLines at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAddressLinesBytes(int index) {
      return instance.getAddressLinesBytes(index);
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param index The index to set the value at.
     * @param value The addressLines to set.
     * @return This builder for chaining.
     */
    public Builder setAddressLines(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setAddressLines(index, value);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param value The addressLines to add.
     * @return This builder for chaining.
     */
    public Builder addAddressLines(
        java.lang.String value) {
      copyOnWrite();
      instance.addAddressLines(value);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param values The addressLines to add.
     * @return This builder for chaining.
     */
    public Builder addAllAddressLines(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllAddressLines(values);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @return This builder for chaining.
     */
    public Builder clearAddressLines() {
      copyOnWrite();
      instance.clearAddressLines();
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     *
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     *
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     *
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9 [json_name = "addressLines"];</code>
     * @param value The bytes of the addressLines to add.
     * @return This builder for chaining.
     */
    public Builder addAddressLinesBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addAddressLinesBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @return A list containing the recipients.
     */
    @java.lang.Override
    public java.util.List<java.lang.String>
        getRecipientsList() {
      return java.util.Collections.unmodifiableList(
          instance.getRecipientsList());
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @return The count of recipients.
     */
    @java.lang.Override
    public int getRecipientsCount() {
      return instance.getRecipientsCount();
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param index The index of the element to return.
     * @return The recipients at the given index.
     */
    @java.lang.Override
    public java.lang.String getRecipients(int index) {
      return instance.getRecipients(index);
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param index The index of the value to return.
     * @return The bytes of the recipients at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRecipientsBytes(int index) {
      return instance.getRecipientsBytes(index);
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param index The index to set the value at.
     * @param value The recipients to set.
     * @return This builder for chaining.
     */
    public Builder setRecipients(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setRecipients(index, value);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param value The recipients to add.
     * @return This builder for chaining.
     */
    public Builder addRecipients(
        java.lang.String value) {
      copyOnWrite();
      instance.addRecipients(value);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param values The recipients to add.
     * @return This builder for chaining.
     */
    public Builder addAllRecipients(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllRecipients(values);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @return This builder for chaining.
     */
    public Builder clearRecipients() {
      copyOnWrite();
      instance.clearRecipients();
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10 [json_name = "recipients"];</code>
     * @param value The bytes of the recipients to add.
     * @return This builder for chaining.
     */
    public Builder addRecipientsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addRecipientsBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>string organization = 11 [json_name = "organization"];</code>
     * @return The organization.
     */
    @java.lang.Override
    public java.lang.String getOrganization() {
      return instance.getOrganization();
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>string organization = 11 [json_name = "organization"];</code>
     * @return The bytes for organization.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOrganizationBytes() {
      return instance.getOrganizationBytes();
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>string organization = 11 [json_name = "organization"];</code>
     * @param value The organization to set.
     * @return This builder for chaining.
     */
    public Builder setOrganization(
        java.lang.String value) {
      copyOnWrite();
      instance.setOrganization(value);
      return this;
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>string organization = 11 [json_name = "organization"];</code>
     * @return This builder for chaining.
     */
    public Builder clearOrganization() {
      copyOnWrite();
      instance.clearOrganization();
      return this;
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>string organization = 11 [json_name = "organization"];</code>
     * @param value The bytes for organization to set.
     * @return This builder for chaining.
     */
    public Builder setOrganizationBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOrganizationBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.type.PostalAddress)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.type.PostalAddress();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "revision_",
            "regionCode_",
            "languageCode_",
            "postalCode_",
            "sortingCode_",
            "administrativeArea_",
            "locality_",
            "sublocality_",
            "addressLines_",
            "recipients_",
            "organization_",
          };
          java.lang.String info =
              "\u0000\u000b\u0000\u0000\u0001\u000b\u000b\u0000\u0002\u0000\u0001\u0004\u0002\u0208" +
              "\u0003\u0208\u0004\u0208\u0005\u0208\u0006\u0208\u0007\u0208\b\u0208\t\u021a\n\u021a" +
              "\u000b\u0208";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<com.google.type.PostalAddress> parser = PARSER;
        if (parser == null) {
          synchronized (com.google.type.PostalAddress.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<com.google.type.PostalAddress>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.type.PostalAddress)
  private static final com.google.type.PostalAddress DEFAULT_INSTANCE;
  static {
    PostalAddress defaultInstance = new PostalAddress();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      PostalAddress.class, defaultInstance);
  }

  public static com.google.type.PostalAddress getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<PostalAddress> PARSER;

  public static com.google.protobuf.Parser<PostalAddress> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

